-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Api.InputObject exposing (..)

import Api.Enum.Ingredients_constraint
import Api.Enum.Ingredients_update_column
import Api.Enum.Order_by
import Api.Enum.Recipes_constraint
import Api.Enum.Recipes_update_column
import Api.Interface
import Api.Object
import Api.Scalar
import Api.ScalarCodecs
import Api.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


buildIngredients_aggregate_order_by :
    (Ingredients_aggregate_order_byOptionalFields -> Ingredients_aggregate_order_byOptionalFields)
    -> Ingredients_aggregate_order_by
buildIngredients_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Ingredients_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Ingredients_avg_order_by
    , count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Ingredients_max_order_by
    , min : OptionalArgument Ingredients_min_order_by
    , stddev : OptionalArgument Ingredients_stddev_order_by
    , stddev_pop : OptionalArgument Ingredients_stddev_pop_order_by
    , stddev_samp : OptionalArgument Ingredients_stddev_samp_order_by
    , sum : OptionalArgument Ingredients_sum_order_by
    , var_pop : OptionalArgument Ingredients_var_pop_order_by
    , var_samp : OptionalArgument Ingredients_var_samp_order_by
    , variance : OptionalArgument Ingredients_variance_order_by
    }


{-| Type for the Ingredients\_aggregate\_order\_by input object.
-}
type alias Ingredients_aggregate_order_by =
    { avg : OptionalArgument Ingredients_avg_order_by
    , count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Ingredients_max_order_by
    , min : OptionalArgument Ingredients_min_order_by
    , stddev : OptionalArgument Ingredients_stddev_order_by
    , stddev_pop : OptionalArgument Ingredients_stddev_pop_order_by
    , stddev_samp : OptionalArgument Ingredients_stddev_samp_order_by
    , sum : OptionalArgument Ingredients_sum_order_by
    , var_pop : OptionalArgument Ingredients_var_pop_order_by
    , var_samp : OptionalArgument Ingredients_var_samp_order_by
    , variance : OptionalArgument Ingredients_variance_order_by
    }


{-| Encode a Ingredients\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_aggregate_order_by : Ingredients_aggregate_order_by -> Value
encodeIngredients_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeIngredients_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeIngredients_max_order_by |> Encode.optional input.max ), ( "min", encodeIngredients_min_order_by |> Encode.optional input.min ), ( "stddev", encodeIngredients_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeIngredients_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeIngredients_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeIngredients_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeIngredients_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeIngredients_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeIngredients_variance_order_by |> Encode.optional input.variance ) ]


buildIngredients_arr_rel_insert_input :
    Ingredients_arr_rel_insert_inputRequiredFields
    -> (Ingredients_arr_rel_insert_inputOptionalFields -> Ingredients_arr_rel_insert_inputOptionalFields)
    -> Ingredients_arr_rel_insert_input
buildIngredients_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Ingredients_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Ingredients_arr_rel_insert_inputRequiredFields =
    { data : List Ingredients_insert_input }


type alias Ingredients_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Ingredients_on_conflict }


{-| Type alias for the `Ingredients_arr_rel_insert_input` attributes. Note that this type
needs to use the `Ingredients_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ingredients_arr_rel_insert_inputRaw =
    { data : List Ingredients_insert_input
    , on_conflict : OptionalArgument Ingredients_on_conflict
    }


{-| Type for the Ingredients\_arr\_rel\_insert\_input input object.
-}
type Ingredients_arr_rel_insert_input
    = Ingredients_arr_rel_insert_input Ingredients_arr_rel_insert_inputRaw


{-| Encode a Ingredients\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeIngredients_arr_rel_insert_input : Ingredients_arr_rel_insert_input -> Value
encodeIngredients_arr_rel_insert_input (Ingredients_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeIngredients_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeIngredients_on_conflict |> Encode.optional input.on_conflict ) ]


buildIngredients_avg_order_by :
    (Ingredients_avg_order_byOptionalFields -> Ingredients_avg_order_byOptionalFields)
    -> Ingredients_avg_order_by
buildIngredients_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_avg_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_avg\_order\_by input object.
-}
type alias Ingredients_avg_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_avg\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_avg_order_by : Ingredients_avg_order_by -> Value
encodeIngredients_avg_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_bool_exp :
    (Ingredients_bool_expOptionalFields -> Ingredients_bool_expOptionalFields)
    -> Ingredients_bool_exp
buildIngredients_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, additional_information = Absent, amount = Absent, amount_unit = Absent, id = Absent, name = Absent, recipe = Absent, recipeByRecipe = Absent }
    in
    Ingredients_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, additional_information = optionals.additional_information, amount = optionals.amount, amount_unit = optionals.amount_unit, id = optionals.id, name = optionals.name, recipe = optionals.recipe, recipeByRecipe = optionals.recipeByRecipe }


type alias Ingredients_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Ingredients_bool_exp))
    , not_ : OptionalArgument Ingredients_bool_exp
    , or_ : OptionalArgument (List (Maybe Ingredients_bool_exp))
    , additional_information : OptionalArgument String_comparison_exp
    , amount : OptionalArgument Numeric_comparison_exp
    , amount_unit : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , recipe : OptionalArgument Int_comparison_exp
    , recipeByRecipe : OptionalArgument Recipes_bool_exp
    }


{-| Type alias for the `Ingredients_bool_exp` attributes. Note that this type
needs to use the `Ingredients_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ingredients_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Ingredients_bool_exp))
    , not_ : OptionalArgument Ingredients_bool_exp
    , or_ : OptionalArgument (List (Maybe Ingredients_bool_exp))
    , additional_information : OptionalArgument String_comparison_exp
    , amount : OptionalArgument Numeric_comparison_exp
    , amount_unit : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , name : OptionalArgument String_comparison_exp
    , recipe : OptionalArgument Int_comparison_exp
    , recipeByRecipe : OptionalArgument Recipes_bool_exp
    }


{-| Type for the Ingredients\_bool\_exp input object.
-}
type Ingredients_bool_exp
    = Ingredients_bool_exp Ingredients_bool_expRaw


{-| Encode a Ingredients\_bool\_exp into a value that can be used as an argument.
-}
encodeIngredients_bool_exp : Ingredients_bool_exp -> Value
encodeIngredients_bool_exp (Ingredients_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeIngredients_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeIngredients_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeIngredients_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "additional_information", encodeString_comparison_exp |> Encode.optional input.additional_information ), ( "amount", encodeNumeric_comparison_exp |> Encode.optional input.amount ), ( "amount_unit", encodeString_comparison_exp |> Encode.optional input.amount_unit ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ), ( "recipe", encodeInt_comparison_exp |> Encode.optional input.recipe ), ( "recipeByRecipe", encodeRecipes_bool_exp |> Encode.optional input.recipeByRecipe ) ]


buildIngredients_inc_input :
    (Ingredients_inc_inputOptionalFields -> Ingredients_inc_inputOptionalFields)
    -> Ingredients_inc_input
buildIngredients_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_inc_inputOptionalFields =
    { amount : OptionalArgument Api.ScalarCodecs.Numeric
    , id : OptionalArgument Int
    , recipe : OptionalArgument Int
    }


{-| Type for the Ingredients\_inc\_input input object.
-}
type alias Ingredients_inc_input =
    { amount : OptionalArgument Api.ScalarCodecs.Numeric
    , id : OptionalArgument Int
    , recipe : OptionalArgument Int
    }


{-| Encode a Ingredients\_inc\_input into a value that can be used as an argument.
-}
encodeIngredients_inc_input : Ingredients_inc_input -> Value
encodeIngredients_inc_input input =
    Encode.maybeObject
        [ ( "amount", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.amount ), ( "id", Encode.int |> Encode.optional input.id ), ( "recipe", Encode.int |> Encode.optional input.recipe ) ]


buildIngredients_insert_input :
    (Ingredients_insert_inputOptionalFields -> Ingredients_insert_inputOptionalFields)
    -> Ingredients_insert_input
buildIngredients_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { additional_information = Absent, amount = Absent, amount_unit = Absent, id = Absent, name = Absent, recipe = Absent, recipeByRecipe = Absent }
    in
    Ingredients_insert_input { additional_information = optionals.additional_information, amount = optionals.amount, amount_unit = optionals.amount_unit, id = optionals.id, name = optionals.name, recipe = optionals.recipe, recipeByRecipe = optionals.recipeByRecipe }


type alias Ingredients_insert_inputOptionalFields =
    { additional_information : OptionalArgument String
    , amount : OptionalArgument Api.ScalarCodecs.Numeric
    , amount_unit : OptionalArgument String
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , recipe : OptionalArgument Int
    , recipeByRecipe : OptionalArgument Recipes_obj_rel_insert_input
    }


{-| Type alias for the `Ingredients_insert_input` attributes. Note that this type
needs to use the `Ingredients_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ingredients_insert_inputRaw =
    { additional_information : OptionalArgument String
    , amount : OptionalArgument Api.ScalarCodecs.Numeric
    , amount_unit : OptionalArgument String
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , recipe : OptionalArgument Int
    , recipeByRecipe : OptionalArgument Recipes_obj_rel_insert_input
    }


{-| Type for the Ingredients\_insert\_input input object.
-}
type Ingredients_insert_input
    = Ingredients_insert_input Ingredients_insert_inputRaw


{-| Encode a Ingredients\_insert\_input into a value that can be used as an argument.
-}
encodeIngredients_insert_input : Ingredients_insert_input -> Value
encodeIngredients_insert_input (Ingredients_insert_input input) =
    Encode.maybeObject
        [ ( "additional_information", Encode.string |> Encode.optional input.additional_information ), ( "amount", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.amount ), ( "amount_unit", Encode.string |> Encode.optional input.amount_unit ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "recipe", Encode.int |> Encode.optional input.recipe ), ( "recipeByRecipe", encodeRecipes_obj_rel_insert_input |> Encode.optional input.recipeByRecipe ) ]


buildIngredients_max_order_by :
    (Ingredients_max_order_byOptionalFields -> Ingredients_max_order_byOptionalFields)
    -> Ingredients_max_order_by
buildIngredients_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { additional_information = Absent, amount = Absent, amount_unit = Absent, id = Absent, name = Absent, recipe = Absent }
    in
    { additional_information = optionals.additional_information, amount = optionals.amount, amount_unit = optionals.amount_unit, id = optionals.id, name = optionals.name, recipe = optionals.recipe }


type alias Ingredients_max_order_byOptionalFields =
    { additional_information : OptionalArgument Api.Enum.Order_by.Order_by
    , amount : OptionalArgument Api.Enum.Order_by.Order_by
    , amount_unit : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_max\_order\_by input object.
-}
type alias Ingredients_max_order_by =
    { additional_information : OptionalArgument Api.Enum.Order_by.Order_by
    , amount : OptionalArgument Api.Enum.Order_by.Order_by
    , amount_unit : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_max\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_max_order_by : Ingredients_max_order_by -> Value
encodeIngredients_max_order_by input =
    Encode.maybeObject
        [ ( "additional_information", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.additional_information ), ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "amount_unit", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount_unit ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_min_order_by :
    (Ingredients_min_order_byOptionalFields -> Ingredients_min_order_byOptionalFields)
    -> Ingredients_min_order_by
buildIngredients_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { additional_information = Absent, amount = Absent, amount_unit = Absent, id = Absent, name = Absent, recipe = Absent }
    in
    { additional_information = optionals.additional_information, amount = optionals.amount, amount_unit = optionals.amount_unit, id = optionals.id, name = optionals.name, recipe = optionals.recipe }


type alias Ingredients_min_order_byOptionalFields =
    { additional_information : OptionalArgument Api.Enum.Order_by.Order_by
    , amount : OptionalArgument Api.Enum.Order_by.Order_by
    , amount_unit : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_min\_order\_by input object.
-}
type alias Ingredients_min_order_by =
    { additional_information : OptionalArgument Api.Enum.Order_by.Order_by
    , amount : OptionalArgument Api.Enum.Order_by.Order_by
    , amount_unit : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_min\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_min_order_by : Ingredients_min_order_by -> Value
encodeIngredients_min_order_by input =
    Encode.maybeObject
        [ ( "additional_information", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.additional_information ), ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "amount_unit", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount_unit ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_obj_rel_insert_input :
    Ingredients_obj_rel_insert_inputRequiredFields
    -> (Ingredients_obj_rel_insert_inputOptionalFields -> Ingredients_obj_rel_insert_inputOptionalFields)
    -> Ingredients_obj_rel_insert_input
buildIngredients_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Ingredients_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Ingredients_obj_rel_insert_inputRequiredFields =
    { data : Ingredients_insert_input }


type alias Ingredients_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Ingredients_on_conflict }


{-| Type alias for the `Ingredients_obj_rel_insert_input` attributes. Note that this type
needs to use the `Ingredients_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ingredients_obj_rel_insert_inputRaw =
    { data : Ingredients_insert_input
    , on_conflict : OptionalArgument Ingredients_on_conflict
    }


{-| Type for the Ingredients\_obj\_rel\_insert\_input input object.
-}
type Ingredients_obj_rel_insert_input
    = Ingredients_obj_rel_insert_input Ingredients_obj_rel_insert_inputRaw


{-| Encode a Ingredients\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeIngredients_obj_rel_insert_input : Ingredients_obj_rel_insert_input -> Value
encodeIngredients_obj_rel_insert_input (Ingredients_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeIngredients_insert_input input.data |> Just ), ( "on_conflict", encodeIngredients_on_conflict |> Encode.optional input.on_conflict ) ]


buildIngredients_on_conflict :
    Ingredients_on_conflictRequiredFields
    -> (Ingredients_on_conflictOptionalFields -> Ingredients_on_conflictOptionalFields)
    -> Ingredients_on_conflict
buildIngredients_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Ingredients_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Ingredients_on_conflictRequiredFields =
    { constraint : Api.Enum.Ingredients_constraint.Ingredients_constraint
    , update_columns : List Api.Enum.Ingredients_update_column.Ingredients_update_column
    }


type alias Ingredients_on_conflictOptionalFields =
    { where_ : OptionalArgument Ingredients_bool_exp }


{-| Type alias for the `Ingredients_on_conflict` attributes. Note that this type
needs to use the `Ingredients_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ingredients_on_conflictRaw =
    { constraint : Api.Enum.Ingredients_constraint.Ingredients_constraint
    , update_columns : List Api.Enum.Ingredients_update_column.Ingredients_update_column
    , where_ : OptionalArgument Ingredients_bool_exp
    }


{-| Type for the Ingredients\_on\_conflict input object.
-}
type Ingredients_on_conflict
    = Ingredients_on_conflict Ingredients_on_conflictRaw


{-| Encode a Ingredients\_on\_conflict into a value that can be used as an argument.
-}
encodeIngredients_on_conflict : Ingredients_on_conflict -> Value
encodeIngredients_on_conflict (Ingredients_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Ingredients_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Ingredients_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeIngredients_bool_exp |> Encode.optional input.where_ ) ]


buildIngredients_order_by :
    (Ingredients_order_byOptionalFields -> Ingredients_order_byOptionalFields)
    -> Ingredients_order_by
buildIngredients_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { additional_information = Absent, amount = Absent, amount_unit = Absent, id = Absent, name = Absent, recipe = Absent, recipeByRecipe = Absent }
    in
    Ingredients_order_by { additional_information = optionals.additional_information, amount = optionals.amount, amount_unit = optionals.amount_unit, id = optionals.id, name = optionals.name, recipe = optionals.recipe, recipeByRecipe = optionals.recipeByRecipe }


type alias Ingredients_order_byOptionalFields =
    { additional_information : OptionalArgument Api.Enum.Order_by.Order_by
    , amount : OptionalArgument Api.Enum.Order_by.Order_by
    , amount_unit : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    , recipeByRecipe : OptionalArgument Recipes_order_by
    }


{-| Type alias for the `Ingredients_order_by` attributes. Note that this type
needs to use the `Ingredients_order_by` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Ingredients_order_byRaw =
    { additional_information : OptionalArgument Api.Enum.Order_by.Order_by
    , amount : OptionalArgument Api.Enum.Order_by.Order_by
    , amount_unit : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    , recipeByRecipe : OptionalArgument Recipes_order_by
    }


{-| Type for the Ingredients\_order\_by input object.
-}
type Ingredients_order_by
    = Ingredients_order_by Ingredients_order_byRaw


{-| Encode a Ingredients\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_order_by : Ingredients_order_by -> Value
encodeIngredients_order_by (Ingredients_order_by input) =
    Encode.maybeObject
        [ ( "additional_information", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.additional_information ), ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "amount_unit", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount_unit ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ), ( "recipeByRecipe", encodeRecipes_order_by |> Encode.optional input.recipeByRecipe ) ]


buildIngredients_pk_columns_input :
    Ingredients_pk_columns_inputRequiredFields
    -> Ingredients_pk_columns_input
buildIngredients_pk_columns_input required =
    { id = required.id }


type alias Ingredients_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Ingredients\_pk\_columns\_input input object.
-}
type alias Ingredients_pk_columns_input =
    { id : Int }


{-| Encode a Ingredients\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeIngredients_pk_columns_input : Ingredients_pk_columns_input -> Value
encodeIngredients_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]


buildIngredients_set_input :
    (Ingredients_set_inputOptionalFields -> Ingredients_set_inputOptionalFields)
    -> Ingredients_set_input
buildIngredients_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { additional_information = Absent, amount = Absent, amount_unit = Absent, id = Absent, name = Absent, recipe = Absent }
    in
    { additional_information = optionals.additional_information, amount = optionals.amount, amount_unit = optionals.amount_unit, id = optionals.id, name = optionals.name, recipe = optionals.recipe }


type alias Ingredients_set_inputOptionalFields =
    { additional_information : OptionalArgument String
    , amount : OptionalArgument Api.ScalarCodecs.Numeric
    , amount_unit : OptionalArgument String
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , recipe : OptionalArgument Int
    }


{-| Type for the Ingredients\_set\_input input object.
-}
type alias Ingredients_set_input =
    { additional_information : OptionalArgument String
    , amount : OptionalArgument Api.ScalarCodecs.Numeric
    , amount_unit : OptionalArgument String
    , id : OptionalArgument Int
    , name : OptionalArgument String
    , recipe : OptionalArgument Int
    }


{-| Encode a Ingredients\_set\_input into a value that can be used as an argument.
-}
encodeIngredients_set_input : Ingredients_set_input -> Value
encodeIngredients_set_input input =
    Encode.maybeObject
        [ ( "additional_information", Encode.string |> Encode.optional input.additional_information ), ( "amount", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.amount ), ( "amount_unit", Encode.string |> Encode.optional input.amount_unit ), ( "id", Encode.int |> Encode.optional input.id ), ( "name", Encode.string |> Encode.optional input.name ), ( "recipe", Encode.int |> Encode.optional input.recipe ) ]


buildIngredients_stddev_order_by :
    (Ingredients_stddev_order_byOptionalFields -> Ingredients_stddev_order_byOptionalFields)
    -> Ingredients_stddev_order_by
buildIngredients_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_stddev_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_stddev\_order\_by input object.
-}
type alias Ingredients_stddev_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_stddev_order_by : Ingredients_stddev_order_by -> Value
encodeIngredients_stddev_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_stddev_pop_order_by :
    (Ingredients_stddev_pop_order_byOptionalFields -> Ingredients_stddev_pop_order_byOptionalFields)
    -> Ingredients_stddev_pop_order_by
buildIngredients_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_stddev_pop_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_stddev\_pop\_order\_by input object.
-}
type alias Ingredients_stddev_pop_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_stddev_pop_order_by : Ingredients_stddev_pop_order_by -> Value
encodeIngredients_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_stddev_samp_order_by :
    (Ingredients_stddev_samp_order_byOptionalFields -> Ingredients_stddev_samp_order_byOptionalFields)
    -> Ingredients_stddev_samp_order_by
buildIngredients_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_stddev_samp_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_stddev\_samp\_order\_by input object.
-}
type alias Ingredients_stddev_samp_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_stddev_samp_order_by : Ingredients_stddev_samp_order_by -> Value
encodeIngredients_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_sum_order_by :
    (Ingredients_sum_order_byOptionalFields -> Ingredients_sum_order_byOptionalFields)
    -> Ingredients_sum_order_by
buildIngredients_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_sum_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_sum\_order\_by input object.
-}
type alias Ingredients_sum_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_sum\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_sum_order_by : Ingredients_sum_order_by -> Value
encodeIngredients_sum_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_var_pop_order_by :
    (Ingredients_var_pop_order_byOptionalFields -> Ingredients_var_pop_order_byOptionalFields)
    -> Ingredients_var_pop_order_by
buildIngredients_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_var_pop_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_var\_pop\_order\_by input object.
-}
type alias Ingredients_var_pop_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_var_pop_order_by : Ingredients_var_pop_order_by -> Value
encodeIngredients_var_pop_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_var_samp_order_by :
    (Ingredients_var_samp_order_byOptionalFields -> Ingredients_var_samp_order_byOptionalFields)
    -> Ingredients_var_samp_order_by
buildIngredients_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_var_samp_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_var\_samp\_order\_by input object.
-}
type alias Ingredients_var_samp_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_var_samp_order_by : Ingredients_var_samp_order_by -> Value
encodeIngredients_var_samp_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildIngredients_variance_order_by :
    (Ingredients_variance_order_byOptionalFields -> Ingredients_variance_order_byOptionalFields)
    -> Ingredients_variance_order_by
buildIngredients_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { amount = Absent, id = Absent, recipe = Absent }
    in
    { amount = optionals.amount, id = optionals.id, recipe = optionals.recipe }


type alias Ingredients_variance_order_byOptionalFields =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Ingredients\_variance\_order\_by input object.
-}
type alias Ingredients_variance_order_by =
    { amount : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , recipe : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Ingredients\_variance\_order\_by into a value that can be used as an argument.
-}
encodeIngredients_variance_order_by : Ingredients_variance_order_by -> Value
encodeIngredients_variance_order_by input =
    Encode.maybeObject
        [ ( "amount", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.amount ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "recipe", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.recipe ) ]


buildInt_comparison_exp :
    (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields)
    -> Int_comparison_exp
buildInt_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildNumeric_comparison_exp :
    (Numeric_comparison_expOptionalFields -> Numeric_comparison_expOptionalFields)
    -> Numeric_comparison_exp
buildNumeric_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Numeric_comparison_expOptionalFields =
    { eq_ : OptionalArgument Api.ScalarCodecs.Numeric
    , gt_ : OptionalArgument Api.ScalarCodecs.Numeric
    , gte_ : OptionalArgument Api.ScalarCodecs.Numeric
    , in_ : OptionalArgument (List Api.ScalarCodecs.Numeric)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Numeric
    , lte_ : OptionalArgument Api.ScalarCodecs.Numeric
    , neq_ : OptionalArgument Api.ScalarCodecs.Numeric
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Numeric)
    }


{-| Type for the Numeric\_comparison\_exp input object.
-}
type alias Numeric_comparison_exp =
    { eq_ : OptionalArgument Api.ScalarCodecs.Numeric
    , gt_ : OptionalArgument Api.ScalarCodecs.Numeric
    , gte_ : OptionalArgument Api.ScalarCodecs.Numeric
    , in_ : OptionalArgument (List Api.ScalarCodecs.Numeric)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Api.ScalarCodecs.Numeric
    , lte_ : OptionalArgument Api.ScalarCodecs.Numeric
    , neq_ : OptionalArgument Api.ScalarCodecs.Numeric
    , nin_ : OptionalArgument (List Api.ScalarCodecs.Numeric)
    }


{-| Encode a Numeric\_comparison\_exp into a value that can be used as an argument.
-}
encodeNumeric_comparison_exp : Numeric_comparison_exp -> Value
encodeNumeric_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.eq_ ), ( "_gt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.gt_ ), ( "_gte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.gte_ ), ( "_in", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.lt_ ), ( "_lte", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.lte_ ), ( "_neq", (Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.optional input.neq_ ), ( "_nin", ((Api.ScalarCodecs.codecs |> Api.Scalar.unwrapEncoder .codecNumeric) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildRecipes_aggregate_order_by :
    (Recipes_aggregate_order_byOptionalFields -> Recipes_aggregate_order_byOptionalFields)
    -> Recipes_aggregate_order_by
buildRecipes_aggregate_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { avg = Absent, count = Absent, max = Absent, min = Absent, stddev = Absent, stddev_pop = Absent, stddev_samp = Absent, sum = Absent, var_pop = Absent, var_samp = Absent, variance = Absent }
    in
    { avg = optionals.avg, count = optionals.count, max = optionals.max, min = optionals.min, stddev = optionals.stddev, stddev_pop = optionals.stddev_pop, stddev_samp = optionals.stddev_samp, sum = optionals.sum, var_pop = optionals.var_pop, var_samp = optionals.var_samp, variance = optionals.variance }


type alias Recipes_aggregate_order_byOptionalFields =
    { avg : OptionalArgument Recipes_avg_order_by
    , count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Recipes_max_order_by
    , min : OptionalArgument Recipes_min_order_by
    , stddev : OptionalArgument Recipes_stddev_order_by
    , stddev_pop : OptionalArgument Recipes_stddev_pop_order_by
    , stddev_samp : OptionalArgument Recipes_stddev_samp_order_by
    , sum : OptionalArgument Recipes_sum_order_by
    , var_pop : OptionalArgument Recipes_var_pop_order_by
    , var_samp : OptionalArgument Recipes_var_samp_order_by
    , variance : OptionalArgument Recipes_variance_order_by
    }


{-| Type for the Recipes\_aggregate\_order\_by input object.
-}
type alias Recipes_aggregate_order_by =
    { avg : OptionalArgument Recipes_avg_order_by
    , count : OptionalArgument Api.Enum.Order_by.Order_by
    , max : OptionalArgument Recipes_max_order_by
    , min : OptionalArgument Recipes_min_order_by
    , stddev : OptionalArgument Recipes_stddev_order_by
    , stddev_pop : OptionalArgument Recipes_stddev_pop_order_by
    , stddev_samp : OptionalArgument Recipes_stddev_samp_order_by
    , sum : OptionalArgument Recipes_sum_order_by
    , var_pop : OptionalArgument Recipes_var_pop_order_by
    , var_samp : OptionalArgument Recipes_var_samp_order_by
    , variance : OptionalArgument Recipes_variance_order_by
    }


{-| Encode a Recipes\_aggregate\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_aggregate_order_by : Recipes_aggregate_order_by -> Value
encodeRecipes_aggregate_order_by input =
    Encode.maybeObject
        [ ( "avg", encodeRecipes_avg_order_by |> Encode.optional input.avg ), ( "count", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.count ), ( "max", encodeRecipes_max_order_by |> Encode.optional input.max ), ( "min", encodeRecipes_min_order_by |> Encode.optional input.min ), ( "stddev", encodeRecipes_stddev_order_by |> Encode.optional input.stddev ), ( "stddev_pop", encodeRecipes_stddev_pop_order_by |> Encode.optional input.stddev_pop ), ( "stddev_samp", encodeRecipes_stddev_samp_order_by |> Encode.optional input.stddev_samp ), ( "sum", encodeRecipes_sum_order_by |> Encode.optional input.sum ), ( "var_pop", encodeRecipes_var_pop_order_by |> Encode.optional input.var_pop ), ( "var_samp", encodeRecipes_var_samp_order_by |> Encode.optional input.var_samp ), ( "variance", encodeRecipes_variance_order_by |> Encode.optional input.variance ) ]


buildRecipes_arr_rel_insert_input :
    Recipes_arr_rel_insert_inputRequiredFields
    -> (Recipes_arr_rel_insert_inputOptionalFields -> Recipes_arr_rel_insert_inputOptionalFields)
    -> Recipes_arr_rel_insert_input
buildRecipes_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Recipes_arr_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Recipes_arr_rel_insert_inputRequiredFields =
    { data : List Recipes_insert_input }


type alias Recipes_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Recipes_on_conflict }


{-| Type alias for the `Recipes_arr_rel_insert_input` attributes. Note that this type
needs to use the `Recipes_arr_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Recipes_arr_rel_insert_inputRaw =
    { data : List Recipes_insert_input
    , on_conflict : OptionalArgument Recipes_on_conflict
    }


{-| Type for the Recipes\_arr\_rel\_insert\_input input object.
-}
type Recipes_arr_rel_insert_input
    = Recipes_arr_rel_insert_input Recipes_arr_rel_insert_inputRaw


{-| Encode a Recipes\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeRecipes_arr_rel_insert_input : Recipes_arr_rel_insert_input -> Value
encodeRecipes_arr_rel_insert_input (Recipes_arr_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", (encodeRecipes_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeRecipes_on_conflict |> Encode.optional input.on_conflict ) ]


buildRecipes_avg_order_by :
    (Recipes_avg_order_byOptionalFields -> Recipes_avg_order_byOptionalFields)
    -> Recipes_avg_order_by
buildRecipes_avg_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_avg_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_avg\_order\_by input object.
-}
type alias Recipes_avg_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_avg\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_avg_order_by : Recipes_avg_order_by -> Value
encodeRecipes_avg_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildRecipes_bool_exp :
    (Recipes_bool_expOptionalFields -> Recipes_bool_expOptionalFields)
    -> Recipes_bool_exp
buildRecipes_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, cover_image_url = Absent, description = Absent, id = Absent, ingredients = Absent, instructions = Absent, name = Absent }
    in
    Recipes_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, cover_image_url = optionals.cover_image_url, description = optionals.description, id = optionals.id, ingredients = optionals.ingredients, instructions = optionals.instructions, name = optionals.name }


type alias Recipes_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Recipes_bool_exp))
    , not_ : OptionalArgument Recipes_bool_exp
    , or_ : OptionalArgument (List (Maybe Recipes_bool_exp))
    , cover_image_url : OptionalArgument String_comparison_exp
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , ingredients : OptionalArgument Ingredients_bool_exp
    , instructions : OptionalArgument String_comparison_exp
    , name : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Recipes_bool_exp` attributes. Note that this type
needs to use the `Recipes_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Recipes_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Recipes_bool_exp))
    , not_ : OptionalArgument Recipes_bool_exp
    , or_ : OptionalArgument (List (Maybe Recipes_bool_exp))
    , cover_image_url : OptionalArgument String_comparison_exp
    , description : OptionalArgument String_comparison_exp
    , id : OptionalArgument Int_comparison_exp
    , ingredients : OptionalArgument Ingredients_bool_exp
    , instructions : OptionalArgument String_comparison_exp
    , name : OptionalArgument String_comparison_exp
    }


{-| Type for the Recipes\_bool\_exp input object.
-}
type Recipes_bool_exp
    = Recipes_bool_exp Recipes_bool_expRaw


{-| Encode a Recipes\_bool\_exp into a value that can be used as an argument.
-}
encodeRecipes_bool_exp : Recipes_bool_exp -> Value
encodeRecipes_bool_exp (Recipes_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeRecipes_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeRecipes_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeRecipes_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "cover_image_url", encodeString_comparison_exp |> Encode.optional input.cover_image_url ), ( "description", encodeString_comparison_exp |> Encode.optional input.description ), ( "id", encodeInt_comparison_exp |> Encode.optional input.id ), ( "ingredients", encodeIngredients_bool_exp |> Encode.optional input.ingredients ), ( "instructions", encodeString_comparison_exp |> Encode.optional input.instructions ), ( "name", encodeString_comparison_exp |> Encode.optional input.name ) ]


buildRecipes_inc_input :
    (Recipes_inc_inputOptionalFields -> Recipes_inc_inputOptionalFields)
    -> Recipes_inc_input
buildRecipes_inc_input fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_inc_inputOptionalFields =
    { id : OptionalArgument Int }


{-| Type for the Recipes\_inc\_input input object.
-}
type alias Recipes_inc_input =
    { id : OptionalArgument Int }


{-| Encode a Recipes\_inc\_input into a value that can be used as an argument.
-}
encodeRecipes_inc_input : Recipes_inc_input -> Value
encodeRecipes_inc_input input =
    Encode.maybeObject
        [ ( "id", Encode.int |> Encode.optional input.id ) ]


buildRecipes_insert_input :
    (Recipes_insert_inputOptionalFields -> Recipes_insert_inputOptionalFields)
    -> Recipes_insert_input
buildRecipes_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { cover_image_url = Absent, description = Absent, id = Absent, ingredients = Absent, instructions = Absent, name = Absent }
    in
    Recipes_insert_input { cover_image_url = optionals.cover_image_url, description = optionals.description, id = optionals.id, ingredients = optionals.ingredients, instructions = optionals.instructions, name = optionals.name }


type alias Recipes_insert_inputOptionalFields =
    { cover_image_url : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument Int
    , ingredients : OptionalArgument Ingredients_arr_rel_insert_input
    , instructions : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Type alias for the `Recipes_insert_input` attributes. Note that this type
needs to use the `Recipes_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Recipes_insert_inputRaw =
    { cover_image_url : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument Int
    , ingredients : OptionalArgument Ingredients_arr_rel_insert_input
    , instructions : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Type for the Recipes\_insert\_input input object.
-}
type Recipes_insert_input
    = Recipes_insert_input Recipes_insert_inputRaw


{-| Encode a Recipes\_insert\_input into a value that can be used as an argument.
-}
encodeRecipes_insert_input : Recipes_insert_input -> Value
encodeRecipes_insert_input (Recipes_insert_input input) =
    Encode.maybeObject
        [ ( "cover_image_url", Encode.string |> Encode.optional input.cover_image_url ), ( "description", Encode.string |> Encode.optional input.description ), ( "id", Encode.int |> Encode.optional input.id ), ( "ingredients", encodeIngredients_arr_rel_insert_input |> Encode.optional input.ingredients ), ( "instructions", Encode.string |> Encode.optional input.instructions ), ( "name", Encode.string |> Encode.optional input.name ) ]


buildRecipes_max_order_by :
    (Recipes_max_order_byOptionalFields -> Recipes_max_order_byOptionalFields)
    -> Recipes_max_order_by
buildRecipes_max_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { cover_image_url = Absent, description = Absent, id = Absent, instructions = Absent, name = Absent }
    in
    { cover_image_url = optionals.cover_image_url, description = optionals.description, id = optionals.id, instructions = optionals.instructions, name = optionals.name }


type alias Recipes_max_order_byOptionalFields =
    { cover_image_url : OptionalArgument Api.Enum.Order_by.Order_by
    , description : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , instructions : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Recipes\_max\_order\_by input object.
-}
type alias Recipes_max_order_by =
    { cover_image_url : OptionalArgument Api.Enum.Order_by.Order_by
    , description : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , instructions : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Recipes\_max\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_max_order_by : Recipes_max_order_by -> Value
encodeRecipes_max_order_by input =
    Encode.maybeObject
        [ ( "cover_image_url", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.cover_image_url ), ( "description", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.description ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "instructions", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.instructions ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildRecipes_min_order_by :
    (Recipes_min_order_byOptionalFields -> Recipes_min_order_byOptionalFields)
    -> Recipes_min_order_by
buildRecipes_min_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { cover_image_url = Absent, description = Absent, id = Absent, instructions = Absent, name = Absent }
    in
    { cover_image_url = optionals.cover_image_url, description = optionals.description, id = optionals.id, instructions = optionals.instructions, name = optionals.name }


type alias Recipes_min_order_byOptionalFields =
    { cover_image_url : OptionalArgument Api.Enum.Order_by.Order_by
    , description : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , instructions : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Recipes\_min\_order\_by input object.
-}
type alias Recipes_min_order_by =
    { cover_image_url : OptionalArgument Api.Enum.Order_by.Order_by
    , description : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , instructions : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Recipes\_min\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_min_order_by : Recipes_min_order_by -> Value
encodeRecipes_min_order_by input =
    Encode.maybeObject
        [ ( "cover_image_url", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.cover_image_url ), ( "description", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.description ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "instructions", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.instructions ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildRecipes_obj_rel_insert_input :
    Recipes_obj_rel_insert_inputRequiredFields
    -> (Recipes_obj_rel_insert_inputOptionalFields -> Recipes_obj_rel_insert_inputOptionalFields)
    -> Recipes_obj_rel_insert_input
buildRecipes_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    Recipes_obj_rel_insert_input { data = required.data, on_conflict = optionals.on_conflict }


type alias Recipes_obj_rel_insert_inputRequiredFields =
    { data : Recipes_insert_input }


type alias Recipes_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Recipes_on_conflict }


{-| Type alias for the `Recipes_obj_rel_insert_input` attributes. Note that this type
needs to use the `Recipes_obj_rel_insert_input` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Recipes_obj_rel_insert_inputRaw =
    { data : Recipes_insert_input
    , on_conflict : OptionalArgument Recipes_on_conflict
    }


{-| Type for the Recipes\_obj\_rel\_insert\_input input object.
-}
type Recipes_obj_rel_insert_input
    = Recipes_obj_rel_insert_input Recipes_obj_rel_insert_inputRaw


{-| Encode a Recipes\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeRecipes_obj_rel_insert_input : Recipes_obj_rel_insert_input -> Value
encodeRecipes_obj_rel_insert_input (Recipes_obj_rel_insert_input input) =
    Encode.maybeObject
        [ ( "data", encodeRecipes_insert_input input.data |> Just ), ( "on_conflict", encodeRecipes_on_conflict |> Encode.optional input.on_conflict ) ]


buildRecipes_on_conflict :
    Recipes_on_conflictRequiredFields
    -> (Recipes_on_conflictOptionalFields -> Recipes_on_conflictOptionalFields)
    -> Recipes_on_conflict
buildRecipes_on_conflict required fillOptionals =
    let
        optionals =
            fillOptionals
                { where_ = Absent }
    in
    Recipes_on_conflict { constraint = required.constraint, update_columns = required.update_columns, where_ = optionals.where_ }


type alias Recipes_on_conflictRequiredFields =
    { constraint : Api.Enum.Recipes_constraint.Recipes_constraint
    , update_columns : List Api.Enum.Recipes_update_column.Recipes_update_column
    }


type alias Recipes_on_conflictOptionalFields =
    { where_ : OptionalArgument Recipes_bool_exp }


{-| Type alias for the `Recipes_on_conflict` attributes. Note that this type
needs to use the `Recipes_on_conflict` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Recipes_on_conflictRaw =
    { constraint : Api.Enum.Recipes_constraint.Recipes_constraint
    , update_columns : List Api.Enum.Recipes_update_column.Recipes_update_column
    , where_ : OptionalArgument Recipes_bool_exp
    }


{-| Type for the Recipes\_on\_conflict input object.
-}
type Recipes_on_conflict
    = Recipes_on_conflict Recipes_on_conflictRaw


{-| Encode a Recipes\_on\_conflict into a value that can be used as an argument.
-}
encodeRecipes_on_conflict : Recipes_on_conflict -> Value
encodeRecipes_on_conflict (Recipes_on_conflict input) =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Api.Enum.Recipes_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Api.Enum.Recipes_update_column.toString |> Encode.list) input.update_columns |> Just ), ( "where", encodeRecipes_bool_exp |> Encode.optional input.where_ ) ]


buildRecipes_order_by :
    (Recipes_order_byOptionalFields -> Recipes_order_byOptionalFields)
    -> Recipes_order_by
buildRecipes_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { cover_image_url = Absent, description = Absent, id = Absent, ingredients_aggregate = Absent, instructions = Absent, name = Absent }
    in
    { cover_image_url = optionals.cover_image_url, description = optionals.description, id = optionals.id, ingredients_aggregate = optionals.ingredients_aggregate, instructions = optionals.instructions, name = optionals.name }


type alias Recipes_order_byOptionalFields =
    { cover_image_url : OptionalArgument Api.Enum.Order_by.Order_by
    , description : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , ingredients_aggregate : OptionalArgument Ingredients_aggregate_order_by
    , instructions : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Type for the Recipes\_order\_by input object.
-}
type alias Recipes_order_by =
    { cover_image_url : OptionalArgument Api.Enum.Order_by.Order_by
    , description : OptionalArgument Api.Enum.Order_by.Order_by
    , id : OptionalArgument Api.Enum.Order_by.Order_by
    , ingredients_aggregate : OptionalArgument Ingredients_aggregate_order_by
    , instructions : OptionalArgument Api.Enum.Order_by.Order_by
    , name : OptionalArgument Api.Enum.Order_by.Order_by
    }


{-| Encode a Recipes\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_order_by : Recipes_order_by -> Value
encodeRecipes_order_by input =
    Encode.maybeObject
        [ ( "cover_image_url", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.cover_image_url ), ( "description", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.description ), ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ), ( "ingredients_aggregate", encodeIngredients_aggregate_order_by |> Encode.optional input.ingredients_aggregate ), ( "instructions", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.instructions ), ( "name", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildRecipes_pk_columns_input :
    Recipes_pk_columns_inputRequiredFields
    -> Recipes_pk_columns_input
buildRecipes_pk_columns_input required =
    { id = required.id }


type alias Recipes_pk_columns_inputRequiredFields =
    { id : Int }


{-| Type for the Recipes\_pk\_columns\_input input object.
-}
type alias Recipes_pk_columns_input =
    { id : Int }


{-| Encode a Recipes\_pk\_columns\_input into a value that can be used as an argument.
-}
encodeRecipes_pk_columns_input : Recipes_pk_columns_input -> Value
encodeRecipes_pk_columns_input input =
    Encode.maybeObject
        [ ( "id", Encode.int input.id |> Just ) ]


buildRecipes_set_input :
    (Recipes_set_inputOptionalFields -> Recipes_set_inputOptionalFields)
    -> Recipes_set_input
buildRecipes_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { cover_image_url = Absent, description = Absent, id = Absent, instructions = Absent, name = Absent }
    in
    { cover_image_url = optionals.cover_image_url, description = optionals.description, id = optionals.id, instructions = optionals.instructions, name = optionals.name }


type alias Recipes_set_inputOptionalFields =
    { cover_image_url : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument Int
    , instructions : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Type for the Recipes\_set\_input input object.
-}
type alias Recipes_set_input =
    { cover_image_url : OptionalArgument String
    , description : OptionalArgument String
    , id : OptionalArgument Int
    , instructions : OptionalArgument String
    , name : OptionalArgument String
    }


{-| Encode a Recipes\_set\_input into a value that can be used as an argument.
-}
encodeRecipes_set_input : Recipes_set_input -> Value
encodeRecipes_set_input input =
    Encode.maybeObject
        [ ( "cover_image_url", Encode.string |> Encode.optional input.cover_image_url ), ( "description", Encode.string |> Encode.optional input.description ), ( "id", Encode.int |> Encode.optional input.id ), ( "instructions", Encode.string |> Encode.optional input.instructions ), ( "name", Encode.string |> Encode.optional input.name ) ]


buildRecipes_stddev_order_by :
    (Recipes_stddev_order_byOptionalFields -> Recipes_stddev_order_byOptionalFields)
    -> Recipes_stddev_order_by
buildRecipes_stddev_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_stddev_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_stddev\_order\_by input object.
-}
type alias Recipes_stddev_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_stddev\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_stddev_order_by : Recipes_stddev_order_by -> Value
encodeRecipes_stddev_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildRecipes_stddev_pop_order_by :
    (Recipes_stddev_pop_order_byOptionalFields -> Recipes_stddev_pop_order_byOptionalFields)
    -> Recipes_stddev_pop_order_by
buildRecipes_stddev_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_stddev_pop_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_stddev\_pop\_order\_by input object.
-}
type alias Recipes_stddev_pop_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_stddev\_pop\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_stddev_pop_order_by : Recipes_stddev_pop_order_by -> Value
encodeRecipes_stddev_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildRecipes_stddev_samp_order_by :
    (Recipes_stddev_samp_order_byOptionalFields -> Recipes_stddev_samp_order_byOptionalFields)
    -> Recipes_stddev_samp_order_by
buildRecipes_stddev_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_stddev_samp_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_stddev\_samp\_order\_by input object.
-}
type alias Recipes_stddev_samp_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_stddev\_samp\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_stddev_samp_order_by : Recipes_stddev_samp_order_by -> Value
encodeRecipes_stddev_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildRecipes_sum_order_by :
    (Recipes_sum_order_byOptionalFields -> Recipes_sum_order_byOptionalFields)
    -> Recipes_sum_order_by
buildRecipes_sum_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_sum_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_sum\_order\_by input object.
-}
type alias Recipes_sum_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_sum\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_sum_order_by : Recipes_sum_order_by -> Value
encodeRecipes_sum_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildRecipes_var_pop_order_by :
    (Recipes_var_pop_order_byOptionalFields -> Recipes_var_pop_order_byOptionalFields)
    -> Recipes_var_pop_order_by
buildRecipes_var_pop_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_var_pop_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_var\_pop\_order\_by input object.
-}
type alias Recipes_var_pop_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_var\_pop\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_var_pop_order_by : Recipes_var_pop_order_by -> Value
encodeRecipes_var_pop_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildRecipes_var_samp_order_by :
    (Recipes_var_samp_order_byOptionalFields -> Recipes_var_samp_order_byOptionalFields)
    -> Recipes_var_samp_order_by
buildRecipes_var_samp_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_var_samp_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_var\_samp\_order\_by input object.
-}
type alias Recipes_var_samp_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_var\_samp\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_var_samp_order_by : Recipes_var_samp_order_by -> Value
encodeRecipes_var_samp_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildRecipes_variance_order_by :
    (Recipes_variance_order_byOptionalFields -> Recipes_variance_order_byOptionalFields)
    -> Recipes_variance_order_by
buildRecipes_variance_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent }
    in
    { id = optionals.id }


type alias Recipes_variance_order_byOptionalFields =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Type for the Recipes\_variance\_order\_by input object.
-}
type alias Recipes_variance_order_by =
    { id : OptionalArgument Api.Enum.Order_by.Order_by }


{-| Encode a Recipes\_variance\_order\_by into a value that can be used as an argument.
-}
encodeRecipes_variance_order_by : Recipes_variance_order_by -> Value
encodeRecipes_variance_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Api.Enum.Order_by.toString |> Encode.optional input.id ) ]


buildString_comparison_exp :
    (String_comparison_expOptionalFields -> String_comparison_expOptionalFields)
    -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]
