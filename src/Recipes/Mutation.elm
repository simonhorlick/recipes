-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Recipes.Mutation exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import Recipes.InputObject
import Recipes.Interface
import Recipes.Object
import Recipes.Scalar
import Recipes.ScalarCodecs
import Recipes.Union


type alias DeleteIngredientsRequiredArguments =
    { where_ : Recipes.InputObject.Ingredients_bool_exp }


{-| delete data from the table: "ingredients"

  - where\_ - filter the rows which have to be deleted

-}
delete_ingredients :
    DeleteIngredientsRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Ingredients_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ingredients requiredArgs object_ =
    Object.selectionForCompositeField "delete_ingredients" [ Argument.required "where" requiredArgs.where_ Recipes.InputObject.encodeIngredients_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeleteIngredientsByPkRequiredArguments =
    { id : Int }


{-| delete single row from the table: "ingredients"
-}
delete_ingredients_by_pk :
    DeleteIngredientsByPkRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Ingredients
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_ingredients_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "delete_ingredients_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias DeleteRecipesRequiredArguments =
    { where_ : Recipes.InputObject.Recipes_bool_exp }


{-| delete data from the table: "recipes"

  - where\_ - filter the rows which have to be deleted

-}
delete_recipes :
    DeleteRecipesRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Recipes_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_recipes requiredArgs object_ =
    Object.selectionForCompositeField "delete_recipes" [ Argument.required "where" requiredArgs.where_ Recipes.InputObject.encodeRecipes_bool_exp ] object_ (identity >> Decode.nullable)


type alias DeleteRecipesByPkRequiredArguments =
    { id : Int }


{-| delete single row from the table: "recipes"
-}
delete_recipes_by_pk :
    DeleteRecipesByPkRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Recipes
    -> SelectionSet (Maybe decodesTo) RootMutation
delete_recipes_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "delete_recipes_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias InsertIngredientsOptionalArguments =
    { on_conflict : OptionalArgument Recipes.InputObject.Ingredients_on_conflict }


type alias InsertIngredientsRequiredArguments =
    { objects : List Recipes.InputObject.Ingredients_insert_input }


{-| insert data into the table: "ingredients"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_ingredients :
    (InsertIngredientsOptionalArguments -> InsertIngredientsOptionalArguments)
    -> InsertIngredientsRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Ingredients_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ingredients fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Recipes.InputObject.encodeIngredients_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_ingredients" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Recipes.InputObject.encodeIngredients_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertIngredientsOneOptionalArguments =
    { on_conflict : OptionalArgument Recipes.InputObject.Ingredients_on_conflict }


type alias InsertIngredientsOneRequiredArguments =
    { object : Recipes.InputObject.Ingredients_insert_input }


{-| insert a single row into the table: "ingredients"

  - object - the row to be inserted
  - on\_conflict - on conflict condition

-}
insert_ingredients_one :
    (InsertIngredientsOneOptionalArguments -> InsertIngredientsOneOptionalArguments)
    -> InsertIngredientsOneRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Ingredients
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_ingredients_one fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Recipes.InputObject.encodeIngredients_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_ingredients_one" (optionalArgs ++ [ Argument.required "object" requiredArgs.object Recipes.InputObject.encodeIngredients_insert_input ]) object_ (identity >> Decode.nullable)


type alias InsertRecipesOptionalArguments =
    { on_conflict : OptionalArgument Recipes.InputObject.Recipes_on_conflict }


type alias InsertRecipesRequiredArguments =
    { objects : List Recipes.InputObject.Recipes_insert_input }


{-| insert data into the table: "recipes"

  - objects - the rows to be inserted
  - on\_conflict - on conflict condition

-}
insert_recipes :
    (InsertRecipesOptionalArguments -> InsertRecipesOptionalArguments)
    -> InsertRecipesRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Recipes_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_recipes fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Recipes.InputObject.encodeRecipes_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_recipes" (optionalArgs ++ [ Argument.required "objects" requiredArgs.objects (Recipes.InputObject.encodeRecipes_insert_input |> Encode.list) ]) object_ (identity >> Decode.nullable)


type alias InsertRecipesOneOptionalArguments =
    { on_conflict : OptionalArgument Recipes.InputObject.Recipes_on_conflict }


type alias InsertRecipesOneRequiredArguments =
    { object : Recipes.InputObject.Recipes_insert_input }


{-| insert a single row into the table: "recipes"

  - object - the row to be inserted
  - on\_conflict - on conflict condition

-}
insert_recipes_one :
    (InsertRecipesOneOptionalArguments -> InsertRecipesOneOptionalArguments)
    -> InsertRecipesOneRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Recipes
    -> SelectionSet (Maybe decodesTo) RootMutation
insert_recipes_one fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { on_conflict = Absent }

        optionalArgs =
            [ Argument.optional "on_conflict" filledInOptionals.on_conflict Recipes.InputObject.encodeRecipes_on_conflict ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "insert_recipes_one" (optionalArgs ++ [ Argument.required "object" requiredArgs.object Recipes.InputObject.encodeRecipes_insert_input ]) object_ (identity >> Decode.nullable)


type alias UpdateIngredientsOptionalArguments =
    { inc_ : OptionalArgument Recipes.InputObject.Ingredients_inc_input
    , set_ : OptionalArgument Recipes.InputObject.Ingredients_set_input
    }


type alias UpdateIngredientsRequiredArguments =
    { where_ : Recipes.InputObject.Ingredients_bool_exp }


{-| update data of the table: "ingredients"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_ingredients :
    (UpdateIngredientsOptionalArguments -> UpdateIngredientsOptionalArguments)
    -> UpdateIngredientsRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Ingredients_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ingredients fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Recipes.InputObject.encodeIngredients_inc_input, Argument.optional "_set" filledInOptionals.set_ Recipes.InputObject.encodeIngredients_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_ingredients" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Recipes.InputObject.encodeIngredients_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdateIngredientsByPkOptionalArguments =
    { inc_ : OptionalArgument Recipes.InputObject.Ingredients_inc_input
    , set_ : OptionalArgument Recipes.InputObject.Ingredients_set_input
    }


type alias UpdateIngredientsByPkRequiredArguments =
    { pk_columns : Recipes.InputObject.Ingredients_pk_columns_input }


{-| update single row of the table: "ingredients"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_ingredients_by_pk :
    (UpdateIngredientsByPkOptionalArguments -> UpdateIngredientsByPkOptionalArguments)
    -> UpdateIngredientsByPkRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Ingredients
    -> SelectionSet (Maybe decodesTo) RootMutation
update_ingredients_by_pk fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Recipes.InputObject.encodeIngredients_inc_input, Argument.optional "_set" filledInOptionals.set_ Recipes.InputObject.encodeIngredients_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_ingredients_by_pk" (optionalArgs ++ [ Argument.required "pk_columns" requiredArgs.pk_columns Recipes.InputObject.encodeIngredients_pk_columns_input ]) object_ (identity >> Decode.nullable)


type alias UpdateRecipesOptionalArguments =
    { inc_ : OptionalArgument Recipes.InputObject.Recipes_inc_input
    , set_ : OptionalArgument Recipes.InputObject.Recipes_set_input
    }


type alias UpdateRecipesRequiredArguments =
    { where_ : Recipes.InputObject.Recipes_bool_exp }


{-| update data of the table: "recipes"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values
  - where\_ - filter the rows which have to be updated

-}
update_recipes :
    (UpdateRecipesOptionalArguments -> UpdateRecipesOptionalArguments)
    -> UpdateRecipesRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Recipes_mutation_response
    -> SelectionSet (Maybe decodesTo) RootMutation
update_recipes fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Recipes.InputObject.encodeRecipes_inc_input, Argument.optional "_set" filledInOptionals.set_ Recipes.InputObject.encodeRecipes_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_recipes" (optionalArgs ++ [ Argument.required "where" requiredArgs.where_ Recipes.InputObject.encodeRecipes_bool_exp ]) object_ (identity >> Decode.nullable)


type alias UpdateRecipesByPkOptionalArguments =
    { inc_ : OptionalArgument Recipes.InputObject.Recipes_inc_input
    , set_ : OptionalArgument Recipes.InputObject.Recipes_set_input
    }


type alias UpdateRecipesByPkRequiredArguments =
    { pk_columns : Recipes.InputObject.Recipes_pk_columns_input }


{-| update single row of the table: "recipes"

  - inc\_ - increments the integer columns with given value of the filtered values
  - set\_ - sets the columns of the filtered rows to the given values

-}
update_recipes_by_pk :
    (UpdateRecipesByPkOptionalArguments -> UpdateRecipesByPkOptionalArguments)
    -> UpdateRecipesByPkRequiredArguments
    -> SelectionSet decodesTo Recipes.Object.Recipes
    -> SelectionSet (Maybe decodesTo) RootMutation
update_recipes_by_pk fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { inc_ = Absent, set_ = Absent }

        optionalArgs =
            [ Argument.optional "_inc" filledInOptionals.inc_ Recipes.InputObject.encodeRecipes_inc_input, Argument.optional "_set" filledInOptionals.set_ Recipes.InputObject.encodeRecipes_set_input ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "update_recipes_by_pk" (optionalArgs ++ [ Argument.required "pk_columns" requiredArgs.pk_columns Recipes.InputObject.encodeRecipes_pk_columns_input ]) object_ (identity >> Decode.nullable)
